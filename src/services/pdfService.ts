// src/services/pdfService.ts
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { marked } from 'marked';
import { BookProject } from '../types';

let isGenerating = false;

const addBrandingFooter = (doc: jsPDF, pageNumber: number, totalPages: number) => {
  const pageHeight = doc.internal.pageSize.getHeight();
  const pageWidth = doc.internal.pageSize.getWidth();
  doc.setFontSize(9);
  doc.setTextColor('#a0a0a0'); // A light grey for the footer

  // Pustakam Branding on the left
  const brandingText = 'Generated by Pustakam AI';
  doc.text(brandingText, 15, pageHeight - 10);
  
  // Page Number on the right
  const pageNumText = `Page ${pageNumber} of ${totalPages}`;
  const textWidth = doc.getStringUnitWidth(pageNumText) * doc.getFontSize() / doc.internal.scaleFactor;
  doc.text(pageNumText, pageWidth - 15 - textWidth, pageHeight - 10);
};

export const pdfService = {
  async generatePdf(project: BookProject, onProgress: (progress: number) => void): Promise<void> {
    if (isGenerating) {
      alert('A PDF is already being generated. Please wait.');
      return;
    }
    if (!project.finalBook) {
      alert('Book content is not available for PDF export.');
      return;
    }

    isGenerating = true;
    onProgress(5);

    try {
      // 1. Create a temporary, off-screen container to render the Markdown as HTML
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.left = '-9999px'; // Position it completely off-screen
      container.style.width = '800px'; // Standard width for rendering to control layout
      container.style.backgroundColor = 'white'; // PDF background
      container.style.color = '#1a1a1a'; // Dark text for readability
      container.style.padding = '40px';
      container.style.fontFamily = 'Georgia, serif'; // Classic book font
      container.style.fontSize = '16px';
      container.style.lineHeight = '1.7';
      
      // Convert the entire Markdown content to an HTML string
      const htmlContent = await marked.parse(project.finalBook);
      container.innerHTML = htmlContent;

      // Apply specific styles for PDF output
      const styles = document.createElement('style');
      styles.innerHTML = `
        h1, h2, h3 { font-family: 'Helvetica', 'Arial', sans-serif; border-bottom: 1px solid #eee; padding-bottom: 8px; margin-top: 24px; }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        pre { background-color: #f5f5f5; padding: 15px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; }
        code { font-family: 'Courier New', monospace; font-size: 0.9em; }
        blockquote { border-left: 3px solid #ccc; padding-left: 15px; margin-left: 0; color: #555; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
        th { background-color: #f9f9f9; }
      `;
      container.appendChild(styles);
      document.body.appendChild(container);

      onProgress(20);

      // 2. Use html2canvas to capture the rendered HTML as a high-quality image
      const canvas = await html2canvas(container, {
        scale: 2, // Higher scale improves text clarity
        useCORS: true,
        logging: false,
        windowWidth: container.scrollWidth,
        windowHeight: container.scrollHeight,
      });

      onProgress(40);
      document.body.removeChild(container); // Clean up the temporary element immediately

      // 3. Initialize the jsPDF document
      const imgData = canvas.toDataURL('image/png');
      const doc = new jsPDF({
        orientation: 'p',
        unit: 'mm',
        format: 'a4',
      });

      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 15;
      const contentWidth = pageWidth - (margin * 2);
      const contentHeight = pageHeight - (margin * 2);

      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      const canvasRatio = canvasHeight / canvasWidth;
      const imgHeight = contentWidth * canvasRatio;

      let heightLeft = imgHeight;
      let position = 0;
      const totalPages = Math.ceil(heightLeft / contentHeight);

      // 4. Add the image content, slicing it into pages with branding
      doc.addImage(imgData, 'PNG', margin, position, contentWidth, imgHeight);
      addBrandingFooter(doc, 1, totalPages);
      heightLeft -= contentHeight;

      let currentPage = 1;
      while (heightLeft > 0) {
        position -= contentHeight;
        currentPage++;
        doc.addPage();
        doc.addImage(imgData, 'PNG', margin, position, contentWidth, imgHeight);
        addBrandingFooter(doc, currentPage, totalPages);
        heightLeft -= contentHeight;

        // Update progress smoothly as pages are added
        const progress = Math.min(95, 40 + (currentPage / totalPages) * 55);
        onProgress(Math.round(progress));
      }
      
      onProgress(98);

      // 5. Save the generated PDF
      const safeTitle = project.title.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '_').toLowerCase();
      doc.save(`${safeTitle}_by_pustakam.pdf`);
      
      onProgress(100);

    } catch (error) {
      console.error('Failed to generate PDF:', error);
      alert('An error occurred while generating the PDF. Please check the console for details.');
      onProgress(0);
    } finally {
      isGenerating = false;
    }
  }
};
